/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <dlfcn.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <vector>
#include <android/log.h>
#include <android/native_window.h>
#include <android/native_window_jni.h>
#include "mdplib.h"
#include "avm_cam.h"

/* Header for class com_autochips_avm_AVMCam */

#undef LOG_TAG
#define LOG_TAG "AVMCamJni"
#define _dbg(fmt, ...) do {__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, "[%s:%d] " fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__);} while(0)
#define _err(fmt, ...) do {__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, "[%s:%d] " fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__);} while(0)

#ifndef _Included_com_autochips_avm_AVMCam
#define _Included_com_autochips_avm_AVMCam
#ifdef __cplusplus
extern "C" {
#endif
#undef AVMCam_AVM_CAM_OUTPUT_MODE_NORMAL
#define AVMCam_AVM_CAM_OUTPUT_MODE_NORMAL 0L
#undef AVMCam_AVM_CAM_OUTPUT_MODE_ALL_IN_ONE
#define AVMCam_AVM_CAM_OUTPUT_MODE_ALL_IN_ONE 1L


static const avm_cam_ops* avm_cam = NULL;
static const mdplib_ops* mdplib = NULL;
static int libavm_cam_load (void)
{
    void* dl_hnd = NULL;
    char* dl_err = NULL;
    const avm_cam_ops* (*avm_cam_get_ops_fn)(void) = NULL;
    const mdplib_ops* (*mdplib_get_ops_fn) (void) = NULL;

    dl_hnd = dlopen("libavm_cam.so", RTLD_NOW);
    if (NULL == dl_hnd) {
        dl_err = dlerror();
        _err("dlopen error %s", dl_err);
        return -1;
    }
    
    avm_cam_get_ops_fn = (const avm_cam_ops*(*)()) dlsym(dl_hnd, "avm_cam_get_ops");
    if (NULL == avm_cam_get_ops_fn) {
        dl_err = dlerror();
        _err("dlsym avm_cam_get_ops error %s", dl_err);
        return -1;
    }

    mdplib_get_ops_fn = (const mdplib_ops*(*)())dlsym(dl_hnd, "mdplib_get_ops");
    if (NULL == mdplib_get_ops_fn) {
        dl_err = dlerror();
        _err("dlsym mdplib_get_ops error %s", dl_err);
        return -1;
    }

    avm_cam = avm_cam_get_ops_fn();
    mdplib = mdplib_get_ops_fn();

    return 0;
}

#define WINDOW_FORMAT_NV21   (0x11)
#define WINDOW_FORMAT_YV12   (0x32315659)

//ch=-1: normal mode
//ch=0~4: all channel to one buffer
static int mdpcpyAvmbuf2Nativebuf (mdp_handle h, avm_cam_buf* avmBuf, ANativeWindow_Buffer* nativeBuf, int ch)
{
    if (NULL == h || NULL == avmBuf || NULL == nativeBuf || ch >= AVM_CAM_CHANNEL_MAX) {
        _err("Invalid param");
        return -1;
    }

    //SRC YUYV
    int32_t srcFormat = MDP_PIXEL_FORMAT_YUYV;
    void* srcPtr[3] = {avmBuf->ptr, NULL, NULL};
    uint32_t srcSiz[3] = {(unsigned)(avmBuf->stride * avmBuf->height), 0, 0};
    uint32_t srcPlaneNum = 1;
    int32_t srcWidth = avmBuf->width;
    int32_t srcHeight = avmBuf->height;
    int32_t srcYPitch = avmBuf->stride;
    int32_t srcUVPitch = 0;

    //DST YV12/NV21
    int32_t dstFormat = 0;
    void* dstPtr[3] = {NULL, NULL, NULL};
    uint32_t dstSiz[3] = {0, 0, 0};
    uint32_t dstPlaneNum = 0;
    int32_t dstWidth = nativeBuf->width;
    int32_t dstHeight = nativeBuf->height;
    int32_t dstYPitch = nativeBuf->stride;
    int32_t dstUVPitch = 0;

    if (ch < 0) {
        //Normal mode
        if (WINDOW_FORMAT_YV12 == nativeBuf->format) {
            dstFormat = MDP_PIXEL_FORMAT_YV12;
            dstPlaneNum = 3;
            dstUVPitch = dstYPitch / 2;
            dstSiz[0] = dstYPitch * dstHeight;
            dstSiz[1] = dstUVPitch * dstHeight / 2;
            dstSiz[2] = dstSiz[1];
            dstPtr[0] = (char*)nativeBuf->bits;
            dstPtr[1] = (char*)dstPtr[0] + dstSiz[0];
            dstPtr[2] = (char*)dstPtr[1] + dstSiz[1];
        } else if (WINDOW_FORMAT_NV21 == nativeBuf->format) {
            dstFormat = MDP_PIXEL_FORMAT_NV21;
            dstPlaneNum = 2;
            dstUVPitch = dstYPitch;
            dstSiz[0] = dstYPitch * dstHeight;
            dstSiz[1] = dstUVPitch * dstHeight / 2;
            dstSiz[2] = 0;
            dstPtr[0] = (char*)nativeBuf->bits;
            dstPtr[1] = (char*)dstPtr[0] + dstSiz[0];
            dstPtr[2] = NULL;
        }
    } else {
        //all channel to one buffer
#define OUT_COL_NUM     (2)
#define OUT_ROW_NUM     ((AVM_CAM_CHANNEL_MAX + OUT_COL_NUM - 1) / OUT_COL_NUM)
        dstWidth = nativeBuf->width / OUT_COL_NUM;
        dstHeight = nativeBuf->height / OUT_ROW_NUM;
        if (WINDOW_FORMAT_YV12 == nativeBuf->format) {
            //int32_t padding = nativeBuf->stride - nativeBuf->width * 1;
            dstFormat = MDP_PIXEL_FORMAT_YV12;
            dstPlaneNum = 3;
            dstUVPitch = dstYPitch / 2;
            dstSiz[0] = dstYPitch * (dstHeight - 1) + dstWidth /*+ padding*/;
            dstSiz[1] = dstUVPitch * (dstHeight / 2 - 1) + dstWidth / 2 /*+ padding / 2*/;
            dstSiz[2] = dstSiz[1];
            dstPtr[0] = (char*)nativeBuf->bits;
            dstPtr[0] = (char*)dstPtr[0] + (ch / OUT_COL_NUM) * dstYPitch * dstHeight + (ch % OUT_COL_NUM) * dstWidth;
            dstPtr[1] = (char*)nativeBuf->bits + dstYPitch * nativeBuf->height;
            dstPtr[1] = (char*)dstPtr[1] + (ch / OUT_COL_NUM) * dstUVPitch * dstHeight / 2 + (ch % OUT_COL_NUM) * dstWidth / 2;
            dstPtr[2] = (char*)nativeBuf->bits + dstYPitch * nativeBuf->height * 5 / 4;
            dstPtr[2] = (char*)dstPtr[2] + (ch / OUT_COL_NUM) * dstUVPitch * dstHeight / 2 + (ch % OUT_COL_NUM) * dstWidth / 2;
        } else if (WINDOW_FORMAT_NV21 == nativeBuf->format) {
            //int32_t padding = nativeBuf->stride - nativeBuf->width * 1;
            dstFormat = MDP_PIXEL_FORMAT_NV21;
            dstPlaneNum = 2;
            dstUVPitch = dstYPitch;
            dstSiz[0] = dstYPitch * (dstHeight - 1) + dstWidth /*+ padding*/;
            dstSiz[1] = dstUVPitch * (dstHeight / 2 - 1) + dstWidth /*+ padding*/;
            dstSiz[2] = 0;
            dstPtr[0] = (char*)nativeBuf->bits;
            dstPtr[0] = (char*)dstPtr[0] + (ch / OUT_COL_NUM) * dstYPitch * dstHeight + (ch % OUT_COL_NUM) * dstWidth;
            dstPtr[1] = (char*)nativeBuf->bits + dstYPitch * nativeBuf->height;
            dstPtr[1] = (char*)dstPtr[1] + (ch / OUT_COL_NUM) * dstUVPitch * dstHeight / 2 + (ch % OUT_COL_NUM) * dstWidth;
            dstPtr[2] = NULL;
        }
    }

    int ret = -1;
    ret = mdplib->set_src_buffer(h, srcPtr, srcSiz, srcPlaneNum);
    if (ret < 0) {
        _err("mdplib set_serc_buffer fail %d", ret);
        return ret;
    }

    ret = mdplib->set_dst_buffer(h, dstPtr, dstSiz, dstPlaneNum);
    if (ret < 0) {
        _err("mdplib set_dst_buffer fail %d", ret);
        return ret;
    }

    ret = mdplib->set_src_config(h, srcWidth, srcHeight, srcYPitch, srcUVPitch, srcFormat, NULL);
    if (ret < 0) {
        _err("mdplib set_src_config fail %d", ret);
        return ret;
    }

    ret = mdplib->set_dst_config(h, dstWidth, dstHeight, dstYPitch, dstUVPitch, dstFormat);
    if (ret < 0) {
        _err("mdplib set_dst_config fail %d", ret);
        return ret;
    }

    ret = mdplib->invalidate(h);
    if (ret < 0) {
        _err("mdplib invalidate fail %d", ret);
        return ret;
    }

    return 0;
}

class Mutex_Autolock {
public:
    Mutex_Autolock(pthread_mutex_t& mutex) : mMutex(mutex) {
        pthread_mutex_lock(&mMutex);
    }
    virtual ~Mutex_Autolock() {
        pthread_mutex_unlock(&mMutex);
    }
private:
    pthread_mutex_t& mMutex;
};

static pthread_mutex_t mMutex = PTHREAD_MUTEX_INITIALIZER;
static int mIsStart = false;
static bool mCamChnEn[AVM_CAM_CHANNEL_MAX];
static bool mCamChnReady[AVM_CAM_CHANNEL_MAX];
static mdp_handle mMdpHnd;
static std::vector<int> mOutputMode;
static std::vector<ANativeWindow*> mOutputWindow;
static std::vector<ANativeWindow_Buffer> mOutputBuffer;

static void onSignalChange (int ch, int width, int height)
{
    if (width > 0 && height > 0) {
        _dbg("Channel %d Signal:Ready Size:%dx%d", ch, width, height);
    } else {
        _dbg("Channel %d Signal:Lost", ch);
    }
}

static void onBufferDone (int ch)
{
    avm_cam_buf buf;
    int bufId, ret;
    bool isAllChnSync = true;

    bufId = avm_cam->deque_buf(ch);
    if (bufId < 0) {
        _err("avm_cam_deque_buf() fail. ret = %d", bufId);
        return;
    }

    ret = avm_cam->query_buf(ch, bufId, &buf);
    if (ret < 0) {
        _err("Query avm camera ch %d buf %d fail. %d", ch, bufId, ret);
        avm_cam->queue_buf(ch, bufId);
        return;
    }

    mCamChnReady[ch] = true;

    if (!mCamChnEn[ch]) {
        avm_cam->queue_buf(ch, bufId);
        return;
    }

    for (int i = 0; i < AVM_CAM_CHANNEL_MAX; i++) {
        if (mCamChnEn[i] && !mCamChnReady[i]) {
            isAllChnSync = false;
            break;
        }
    }
    if (isAllChnSync) {
        for (int i = 0; i < AVM_CAM_CHANNEL_MAX; i++) {
            mCamChnReady[i] = false;
        }
    }

    if (mOutputMode.size() <= 0 || mOutputWindow.size() < mOutputMode.size() || mOutputWindow.size() != mOutputBuffer.size()) {
        if (mOutputMode.size() > 0) {
            _err("Invalid output config. mOutputMode.size:%d mOutputWindow.size:%d mOutputBuffer.size:%d",
                 (int)mOutputMode.size(), (int)mOutputWindow.size(), (int)mOutputBuffer.size());
        }
        avm_cam->queue_buf(ch, bufId);
        return;
    }

    unsigned nWinCnt = 0;
    for (unsigned out = 0; out < mOutputMode.size() && nWinCnt < mOutputWindow.size(); out ++) {
        int nWinId = 0;
        if (mOutputMode[out] != AVMCam_AVM_CAM_OUTPUT_MODE_ALL_IN_ONE) {
            nWinId = nWinCnt + ch;
            nWinCnt += AVM_CAM_CHANNEL_MAX;
        } else {
            nWinId = nWinCnt;
            nWinCnt ++;
        }

        ANativeWindow* outWin = mOutputWindow[nWinId];
        ANativeWindow_Buffer* outBuf = &mOutputBuffer[nWinId];

        if (NULL == outWin) {
            continue;
        }

        if (mOutputMode[out] != AVMCam_AVM_CAM_OUTPUT_MODE_ALL_IN_ONE) {
            ret = ANativeWindow_lock(outWin, outBuf, NULL);
            if (ret < 0) {
                _err("NativeWindow %d ANativeWindow_lock() fail. %d", nWinId, ret);
                continue;
            }

            _dbg("ANativeWindow_Buffer %d format %d, size %d x %d, %d", nWinId, outBuf->format, outBuf->width, outBuf->height, outBuf->stride);

            mdpcpyAvmbuf2Nativebuf(mMdpHnd, &buf, outBuf, -1);

            ret = ANativeWindow_unlockAndPost(outWin);
            if (ret < 0) {
                _err("NativeWindow %d ANativeWindow_unlockAndPost() fail. %d", nWinId, ret);
                continue;
            }
            memset(outBuf, 0, sizeof(*outBuf));
        } else {
            if (NULL == outBuf->bits) {
                ret = ANativeWindow_lock(outWin, outBuf, NULL);
                if (ret < 0) {
                    _err("NativeWindow %d ANativeWindow_lock() fail. %d", nWinId, ret);
                    continue;
                }
            }

            _dbg("ANativeWindow_Buffer %d format %d, size %d x %d, %d", nWinId, outBuf->format, outBuf->width, outBuf->height, outBuf->stride);
            mdpcpyAvmbuf2Nativebuf(mMdpHnd, &buf, outBuf, ch);

            if (isAllChnSync) {
                ret = ANativeWindow_unlockAndPost(outWin);
                if (ret < 0) {
                    _err("NativeWindow %d ANativeWindow_unlockAndPost() fail. %d", nWinId, ret);
                    continue;
                }
                memset(outBuf, 0, sizeof(*outBuf));
            }
        }
    }

    avm_cam->queue_buf(ch, bufId);
}

static void event_callback (int event, int ch, int param1, int param2)
{
    while (0 != pthread_mutex_trylock(&mMutex)) {
        if (!mIsStart) {
            return;
        }
        usleep(1000);
    }
    if (!mIsStart) {
        pthread_mutex_unlock(&mMutex);
        return;
    }

    if (ch < 0 || ch >= AVM_CAM_CHANNEL_MAX) {
        pthread_mutex_unlock(&mMutex);
        return;
    }

    switch (event) {
        case AVM_CAM_EVENT_SIGNAL:
            onSignalChange(ch, param1, param2);
            break;
        case AVM_CAM_EVENT_BUF_DONE:
            onBufferDone(ch);
            break;
        default:
            _err("Unknown event:%d ch:%d param1:%d param2:%d", event, ch, param1, param2);
            break;
    }

    pthread_mutex_unlock(&mMutex);
}

/*
 * Class:     com_autochips_avm_AVMCam
 * Method:    open
 * Signature: ()I
 */
JNIEXPORT jint JNICALL AVMCam_open
  (JNIEnv *, jclass)
{
    Mutex_Autolock _lock(mMutex);
    _dbg("Enter");

    if (mIsStart) {
        _err("is started");
        return -1;
    }

    int ret = avm_cam->open(event_callback);
    if (ret < 0) {
        _err("avm camera open fail %d", ret);
        return ret;
    }

    mIsStart = false;
    mMdpHnd = NULL;
    for (int ch = 0; ch < AVM_CAM_CHANNEL_MAX; ch++) {
        mCamChnEn[ch] = false;
        mCamChnReady[ch] = false;
    }

    mOutputMode.clear();
    mOutputWindow.clear();
    mOutputBuffer.clear();

    _dbg("Leave");
    return 0;
}

/*
 * Class:     com_autochips_avm_AVMCam
 * Method:    enableChannel
 * Signature: ([Z)I
 */
JNIEXPORT jint JNICALL AVMCam_enableChannel
  (JNIEnv *env, jclass, jbooleanArray enable)
{
    Mutex_Autolock _lock(mMutex);
    _dbg("Enter");

    if (enable == NULL) {
        _err("enable is null");
        return -1;
    }

    if (mIsStart) {
        _err("is started");
        return -1;
    }

    jboolean *jEnablePtr = env->GetBooleanArrayElements(enable, NULL);
    jsize jEnableLen = env->GetArrayLength(enable);

    if (jEnablePtr == NULL || jEnableLen != AVM_CAM_CHANNEL_MAX) {
        _err("Invalid enable param");
        if (NULL != jEnablePtr) {
            env->ReleaseBooleanArrayElements(enable, jEnablePtr, 0);
        }
        return -1;
    }

    int channel_en[AVM_CAM_CHANNEL_MAX] = {0};
    for (int ch = 0; ch < AVM_CAM_CHANNEL_MAX; ch++) {
        channel_en[ch] = !!jEnablePtr[ch];
    }

    int ret = avm_cam->enable_channel(channel_en);
    if (ret < 0) {
        _err("avm camera enable fail %d", ret);
        env->ReleaseBooleanArrayElements(enable, jEnablePtr, 0);
        return ret;
    }

    for (int ch = 0; ch < AVM_CAM_CHANNEL_MAX; ch++) {
        mCamChnEn[ch] = channel_en[ch];
    }

    env->ReleaseBooleanArrayElements(enable, jEnablePtr, 0);

    _dbg("Leave");
    return 0;
}

/*
 * Class:     com_autochips_avm_AVMCam
 * Method:    setSurface
 * Signature: ([I[Landroid/view/Surface;)I
 */
JNIEXPORT jint JNICALL AVMCam_setSurface
  (JNIEnv *env, jclass, jintArray outModes, jobjectArray outSurfaces)
{
    Mutex_Autolock _lock(mMutex);
    _dbg("Enter");
    int ret = -1;

    for (unsigned winid = 0; winid < mOutputWindow.size(); winid ++) {
        if (NULL != mOutputWindow[winid]) {
            if (NULL != mOutputBuffer[winid].bits) {
                ANativeWindow_unlockAndPost(mOutputWindow[winid]);
            }
            ANativeWindow_release(mOutputWindow[winid]);
        }
    }
    mOutputMode.clear();
    mOutputWindow.clear();
    mOutputBuffer.clear();

    if (NULL == outModes || NULL == outSurfaces) {
        _err("surface is null, destroy?");
        return 0;
    }

    jint *jOutModesPtr = env->GetIntArrayElements(outModes, NULL);
    jsize jOutModesLen = env->GetArrayLength(outModes);
    jsize jOutSurfacesLen = env->GetArrayLength(outSurfaces);

    int winCount = 0;
    for (int i = 0; i < jOutModesLen; i++) {
        if (jOutModesPtr[i] != AVMCam_AVM_CAM_OUTPUT_MODE_ALL_IN_ONE) {
            winCount += AVM_CAM_CHANNEL_MAX;
        } else {
            winCount ++;
        }
    }

    if (winCount != jOutSurfacesLen) {
        _err("Invalid param. outModes.size %d, outSurfaces.size %d, request surface num %d", jOutModesLen, jOutSurfacesLen, winCount);
        env->ReleaseIntArrayElements(outModes, jOutModesPtr, 0);
        return -1;
    }

    mOutputMode.resize(jOutModesLen);
    mOutputWindow.resize(jOutSurfacesLen);
    mOutputBuffer.resize(jOutSurfacesLen);
    winCount = 0;
    for (int out = 0; out < jOutModesLen; out++) {
        mOutputMode[out] = jOutModesPtr[out];
        if (jOutModesPtr[out] != AVMCam_AVM_CAM_OUTPUT_MODE_ALL_IN_ONE) {
            for (int winid = 0; winid < AVM_CAM_CHANNEL_MAX; winid++) {
                ANativeWindow*& nativeWindow = mOutputWindow[winid + winCount];
                ANativeWindow_Buffer& nativeBuffer = mOutputBuffer[winid + winCount];
                nativeWindow = NULL;
                memset(&nativeBuffer, 0, sizeof(nativeBuffer));

                jobject surface = env->GetObjectArrayElement(outSurfaces, winid + winCount);
                if (NULL == surface) {
                    continue;
                }

                nativeWindow = ANativeWindow_fromSurface(env, surface);
                if (NULL == nativeWindow) {
                    _err("get NativeWindow from surface fail  surface id  %d", winid + winCount);
                    return -1;
                }

                ANativeWindow_acquire(nativeWindow);

                int32_t format = ANativeWindow_getFormat(nativeWindow);
                int32_t width = ANativeWindow_getWidth(nativeWindow);
                int32_t height = ANativeWindow_getHeight(nativeWindow);
                if (format != WINDOW_FORMAT_NV21 && format != WINDOW_FORMAT_YV12) {
                    _err("ANativeWindow %d format %d not support, set WINDOW_FORMAT_YV12", winCount + winid, format);
                    format = WINDOW_FORMAT_YV12;
                }
                if (width < 2 || height < 2) {
                    _err("ANativeWindow %d size %d x %d invalid, set 1280 x 720", winCount + winid, width, height);
                    width = 1280;
                    height = 720;
                }
                _dbg("ANativeWindow %d format %d, size %d x %d", winCount + winid, format, width, height);
                ret = ANativeWindow_setBuffersGeometry(nativeWindow, width, height, format);
                if (ret < 0) {
                    _err("setBuffersGeometry() fail. %d", ret);
                    return ret;
                }
            }
            winCount += AVM_CAM_CHANNEL_MAX;
        } else {
            ANativeWindow*& nativeWindow = mOutputWindow[winCount];
            ANativeWindow_Buffer& nativeBuffer = mOutputBuffer[winCount];
            nativeWindow = NULL;
            memset(&nativeBuffer, 0, sizeof(nativeBuffer));

            jobject surface = env->GetObjectArrayElement(outSurfaces, winCount);
            if (NULL == surface) {
                winCount++;
                continue;
            }

            nativeWindow = ANativeWindow_fromSurface(env, surface);
            if (NULL == nativeWindow) {
                _err("get NativeWindow from surface fail  surface id  %d", winCount);
                return -1;
            }

            ANativeWindow_acquire(nativeWindow);

            int32_t format = ANativeWindow_getFormat(nativeWindow);
            int32_t width = ANativeWindow_getWidth(nativeWindow);
            int32_t height = ANativeWindow_getHeight(nativeWindow);
            if (format != WINDOW_FORMAT_NV21 && format != WINDOW_FORMAT_YV12) {
                _err("ANativeWindow %d format %d not support, set WINDOW_FORMAT_YV12", winCount, format);
                format = WINDOW_FORMAT_YV12;
            }
            if (width < 2 || height < 2) {
                _err("ANativeWindow %d size %d x %d invalid, set 1920 x 1080", winCount, width, height);
                width = 1920;
                height = 1080;
            }
            _dbg("ANativeWindow %d format %d, size %d x %d", winCount, format, width, height);
            ret = ANativeWindow_setBuffersGeometry(nativeWindow, width, height, format);
            if (ret < 0) {
                _err("setBuffersGeometry() fail. %d", ret);
                return ret;
            }

            winCount++;
        }
    }

    env->ReleaseIntArrayElements(outModes, jOutModesPtr, 0);

    _dbg("Leave");
    return 0;
}

/*
 * Class:     com_autochips_avm_AVMCam
 * Method:    start
 * Signature: ()I
 */
JNIEXPORT jint JNICALL AVMCam_start
  (JNIEnv *, jclass)
{
    Mutex_Autolock _lock(mMutex);
    _dbg("Enter");

    if (mIsStart) {
        _err("is started");
        return -1;
    }

    int ret = avm_cam->start();
    if (ret < 0) {
        _err("avm camera start fail %d", ret);
        return ret;
    }

    mIsStart = true;
    mMdpHnd = mdplib->create();

    _dbg("Leave");
    return 0;
}

/*
 * Class:     com_autochips_avm_AVMCam
 * Method:    stop
 * Signature: ()I
 */
JNIEXPORT jint JNICALL AVMCam_stop
  (JNIEnv *, jclass)
{
    Mutex_Autolock _lock(mMutex);
    _dbg("Enter");
    int ret = 0;

    if (!mIsStart) {
        _err("not start");
        return -1;
    }

    mIsStart = false;

    ret = avm_cam->stop();
    if (ret < 0) {
        _err("avm camera stop fail. %d", ret);
        return -1;
    }

    mdplib->destroy(mMdpHnd);
    mMdpHnd = NULL;

    _dbg("Leave");
    return 0;
}

/*
 * Class:     com_autochips_avm_AVMCam
 * Method:    close
 * Signature: ()I
 */
JNIEXPORT jint JNICALL AVMCam_close
  (JNIEnv *, jclass)
{
    Mutex_Autolock _lock(mMutex);
    _dbg("Enter");
    int ret = avm_cam->close();
    if (ret < 0) {
        _err("avm camera close fail. %d", ret);
        return -1;
    }
    _dbg("Leave");
    return ret;
}

static const char* const kClassPathName = "com/autochips/avm/AVMCam";

static JNINativeMethod sMethods[] = {
    {"open", "()I", (void*)AVMCam_open},
    {"enableChannel", "([Z)I", (void*)AVMCam_enableChannel},
    {"setSurface",  "([I[Landroid/view/Surface;)I", (void*)AVMCam_setSurface},
    {"start", "()I", (void*)AVMCam_start},
    {"stop", "()I", (void*)AVMCam_stop},
    {"close", "()I", (void*)AVMCam_close}
};

/*
 * JNI Initialization
 */
jint JNI_OnLoad(JavaVM *jvm, void * /*reserved*/) {
    JNIEnv *env;
    int status;
    jclass clazz;

    _dbg("Enter");

    if (jvm->GetEnv((void **) &env, JNI_VERSION_1_6)) {
        //ALOGE("JNI version mismatch error");
        return JNI_ERR;
    }

    clazz = env->FindClass(kClassPathName);
    if (NULL == clazz) {
        _err("Unable to find class com.autochips.avm.AVMCam");
        return -1;
    }

    env->NewGlobalRef(clazz);

    status = (env)->RegisterNatives(clazz, sMethods, sizeof(sMethods) / sizeof(sMethods[0]));
    if (status < 0) {
        return JNI_ERR;
    }

    if (libavm_cam_load() < 0) {
        _err("libavm_cam_load() fail.");
        return JNI_ERR;
    }

    _dbg("Leave");
    return JNI_VERSION_1_6;
}

#ifdef __cplusplus
}
#endif
#endif
